# Trelliscope: Detailed Vis of Large Complex Data in R #

## Intro ##

### Background ###

Trelliscope provides a way to visualize large, complex data in great detail from within the R statistical programming environment.  This package operates on data that has been split into subsets using the [datadr](http://github.com/hafen/datadr) package.  Data can be local R data objects or can be very large data sets supported by the [RHIPE](http://github.com/saptarshiguha/RHIPE) backend of `datadr`.

Trelliscope is based on the concept of Divide and Recombine (D&R).  Some philosophy and background on D&R can be found at [datadr.org](http://www.datadr.org).

#### Reference

Related projects:
   - [datadr][datadr]: R package providing the D&R framework
   - [RHIPE][rhipe]: the engine that enables D&R to work with large, complex data

References:
   - [http://datadr.org][datadr.org]
   - [Trelliscope: A System for Detailed Visualization in the Deep Analysis of Large Complex Data][trspaper]
   - [Large complex data: divide and recombine (D&R) with RHIPE][drpaper]
   - [Visualization Databases for the Analysis of Large Complex Datasets][vdbpaper]

[rhipe]: http://github.com/saptarshiguha/RHIPE
[datadr]: http://github.com/hafen/datadr
[datadr.org]: http://datadr.org
[trspaper]: http://datadr.org/documents/trelliscope.pdf
[drpaper]: http://onlinelibrary.wiley.com/doi/10.1002/sta4.7/full
[vdbpaper]: http://jmlr.csail.mit.edu/proceedings/papers/v5/guha09a/guha09a.pdf
[trellis]: http://www.cs.ubc.ca/~tmm/courses/infovis/readings/trellis.jstor.pdf


### Getting Started ###

Trelliscope is a part of and depends on `datadr`.  It is recommended to spend some time in the `datadr` [tutorial](http://hafen.github.io/datadr/index.html) to get acquainted with the package.  Mainly focusing on the [division](http://hafen.github.io/datadr/index.html#division) aspects and the [backend options](http://hafen.github.io/datadr/index.html#backend-choices) of the package will suffice, although it is recommended to get well-acquainted with the entire package, as Trelliscope is simply a visualization component in the D&R analysis paradigm.

#### Installation

To install Trelliscope, we must first install `datadr`, which is discussed [here](http://hafen.github.io/datadr/index.html#getting-started).

Then, to install Trelliscope:

```r
library(devtools)
install_github("trelliscope", "hafen")
```

Then we load the package:

```{r echo=FALSE, include=FALSE}
# require(lattice)
# require(ggplot2)
# require(digest)
# require(knitr)
# require(markdown)
# require(base64enc)
# require(scagnostics)
# require(data.table)
# ff <- list.files("~/Documents/Code/datadr/R", full.names=TRUE)
# for(f in ff) {
#    cat(f, "\n"); source(f)
# }
# ff <- list.files("~/Documents/Code/trelliscope/R", full.names=TRUE)
# for(f in ff) {
#    cat(f, "\n"); source(f)
# }
# load("~/Documents/Code/trelliscope/inst/data/elnino.rda")
# load("~/Documents/Code/trelliscope/inst/data/airplane.rda")
```

```{r load_trelliscope, warning=FALSE}
library(trelliscope)
```

and we are ready to go.

#### Connecting to a Visualization Database (VDB)

Collections of Trelliscope and other displays created throughout the course of an analysis are organized into a visualization database (VDB) for the project.  Displays can be organized into groups by analysis thread.

The first step to using Trelliscope for an analysis project is to connect to a VDB.  A VDB connection is simply a connection to a directory on disk where all of the VDB files reside or will reside.

```{r echo=FALSE, purl=FALSE, include=FALSE, warning=FALSE, error=FALSE, message=FALSE}
unlink("/private/tmp/vdbtest", recursive=TRUE)
```

```{r vdb_conn}
# initialize a connection to a new VDB to be located at /private/tmp/vdbtest
vdbDir <- "/private/tmp/vdbtest"
conn <- vdbConn(vdbDir, autoYes=TRUE, name="myProject")
```

If the VDB connection directory doesn't exist, it will ask whether it should be created.  Here, we specify `autoYes=TRUE` to automatically answer yes to this question.  In any subsequent R session, we can connect to the existing VDB directory with the same `vdbConn()` command.

Most Trelliscope functions need the VDB connection information to know where to put things.  It can be tedious to always supply this, so `vdbConn()` sets a global R option called `"vdbConn"` that store the connection information.  If in a Trelliscope function we do not explicitly specify the connection, the default is to search for the global `vdbConn` option.  The assumption is that in any one R session, the user will be using just one VDB, and thus there will not be multiple conflicting connections.

We can now look at some examples and start populating the VDB with displays.

### Trellis Display ###

In this section, we will explore an example dataset using the `lattice` package, which is based on Trellis Display, upon which many of the principles of Trelliscope are built.  Note that lattice is not required for plotting in Trelliscope - you can use `ggplot2`, base R graphics, or potentially any other plotting mechanism that can be rendered in a web page.

#### `airplane` data

The Trelliscope package includes a dataset called `airplane` which we will use as an example dataset in this tutorial.  This data is very small and can be analyzed quite easily without the help of trelliscope, but we use it to demonstrate the functionality.  Bear in mind that the same tools apply to much larger data.

Let's first get a feel for the data:

```{r airplane}
data(airplane)
head(airplane)
```

We see a date/time variable, latitude, longitude, altitude, and several measurements.  Here we will focus on the measurement of `co`.

#### `co` vs. time

Let's take a look at `co` vs. time:

```{r airplane_time, fig.height=2.5}
# look at co vs. time
Sys.setenv(TZ="UTC")
xyplot(co ~ dat_ams, data=airplane, aspect=0.2)
```

This plots `co` vs. `dat_ams`, and gives the plot an aspect ratio of 0.2.  Note that aspect ratios are very important for visual perception and should not be an afterthought or not thought of at all when creating a display.

It looks like there are several `co` measurements over the course of a day, split into two chunks with a 4-5 hour gap in between.  It turns out that there are two separate flights - one in the morning and one in the afternoon.

To account for this in our analyses, let's create a new variable `flight` with values `"am"` and `"pm"`:

```{r ap_flight}
# distinguish "am" and "pm" flights
airplane$flight <- ifelse(airplane$dat_ams < as.POSIXct("2010-06-28 21:00:00 UTC"), "am", "pm")
```

#### Altitude vs. time

Another interesting variable is altitude.  If we look at altitude vs. time:

```{r ap_alt, fig.height=2.5}
# look at altitude vs. time
xyplot(altitude ~ dat_ams, data=airplane, aspect=0.2)
```

We see that altitude typically stays fairly constant a little under 500 and 1000, with some interesting quick ascents to higher altitudes.  It may be interesting to investigate different altitude levels, and we can create a discretized altitude variable:

```{r ap_altcut}
# create a discrete version of altitude
airplane$altCut <- cut(airplane$altitude, seq(0, 3000, by=500))
```

#### Flight tracks

We can get a feel for the flight tracks during each flight with the following:

```{r ap_tracks, fig.height=4.5}
# take a look at airplane tracks
xyplot(latitude ~ longitude, data=airplane,
   groups=flight,
   aspect="iso",
   alpha=0.5,
   auto.key=list(space="right")
)
```

The `groups` argument tells lattice to use a different color to plot data corresponding to each flight.  `aspect="iso"` forces the aspect ratio of the plot to be such that the units of the x and y axis are equal according to the physical screen space they cover relative to their units.

#### Adding altitude

Suppose we want to incorporate altitude into the tracks plot.  There are several ways we could do this.  Here, for each flight we plot the tracks colored differently for each level of altitude.

```{r ap_tracks_alt, fig.height=4}
# look at tracks with altitude and flight
library(RColorBrewer)
xyplot(latitude ~ longitude | flight, 
   data=airplane,
   panel=function(x, y, ...) {
      panel.fill("#E0E0E0")
      panel.grid(h=-1, v=-1, col="lightgray")
      panel.xyplot(x, y, ...)
   },
   groups=altCut,
   between=list(x=0.5),
   aspect="iso",
   par.settings=list(superpose.symbol=list(col=brewer.pal(6, "Accent"))),
   auto.key=list(space="right")
)
```

This display introduces several more elements of Trellis Display.  The most important is *conditioning*, or *faceting* on the variable `flight`.  In the R formula interface, this is specified by the `|` operator.  This causes a panel to be rendered independently for each subset defined by the levels of `flight`.

Another notion introduced in this example is that of a panel function.  The panel function provides instructions for what to plot for each panel in the display, and the input to the panel function is a subset of data as specified by the conditioning variables.  The default panel function for `xyplot()` is `panel.xyplot()`.  Here, we use that, but additionally fill the background of each panel and add grid lines (which can also be done by specifying `type=c("p", "g")`).

Other aspects introduced here include the key, specified by `auto.key`, and special settings for the color of the symbols, specified by `par.settings`.  There are several aspects of Trellis Display as implemented in the `lattice` package that we encourage you to look into on your own, starting [here](http://lmdvr.r-forge.r-project.org/figures/figures.html).

#### More on conditioning

As conditioning is the basis of Trelliscope display, we'll cover a few more examples of conditioning, paying particular attention the importance of axis limits for being able to make meaningful judgements of similarities or differences between panels.

Let's take a look at the airplane tracks broken up by time.  First, we will create a new factor variable that groups time by 15 minute intervals:

```{r datcut}
# break time into 15 minute intervals
airplane$datCut <- sprintf("%s:%02d",
   format(airplane$dat_ams, "%m-%d/%H"), 
   floor(as.integer(format(airplane$dat_ams, "%M")) / 15) * 15
)
```

One way we might view the data conditioned on this new time variable is to plot a directional arrow of the flight's path per time interval:

```{r tracks_datcut, fig.height=4}
# plot of airplane tracks by 15 minute intervals
arrowPanel <- function(x, y, ...) {
   n <- length(x)
   panel.grid(h=-1, v=-1)
   panel.arrows(x[1:(n-1)], y[1:(n-1)], x[2:n], y[2:n], length=0.05, alpha=0.3, col="blue")
}

xyplot(latitude ~ longitude | datCut,
   data=airplane,
   panel=arrowPanel,
   as.table=TRUE,
   between=list(x=0.25, y=0.25),
   layout=c(5, 2),
   aspect="iso",
   subset=flight=="pm"
)
```

#### Scales / axis limits

Using this example, an important issue to discuss with Trellis Display is that of *scales*.  When viewing panels of a Trellis display, meaningful visual comparisons between panels greatly depend on how the limits of the x and y axes are determined.  There are three choices for each axis:

- **"same"**: the same limits are used for all the panels
- **"free"**: the limits for each panel are determined by just the points in that panel
- **"sliced"**:  the length (max - min) of the scales are constrained to remain the same across panels

Determining suitable axis limits is dependent on what is being visualized, but typically "same" or "sliced" are good choices as they enable panel-to-panel comparisons, which is where much of the power of this type of visualization lies.  You might choose "sliced" if you are interested in relative behaviors in terms of scale, or "same" if you are interested in relative behaviors both in terms of location and scale.

The handling of panel axis limits is specified by the `scales` argument, which takes a names list of lists with names `x` and `y` for the x and y axes respectively.  There are several options to specify for each axis scale, but `relation` specifies the axis limit behavior.

The default in `lattice` is "same", and we have seen an example of this in our previous plot.  Let's also look at the other options.

#### Free axes

Here is the same plot as before but with both axes "free":

```{r tracks_free, fig.height=4}
# example of both x and y axes "free"
xyplot(latitude ~ longitude | datCut,
   data=airplane,
   panel=arrowPanel,
   as.table=TRUE,
   between=list(x=0.25, y=0.25),
   layout=c(5, 2),
   scales=list(x=list(relation="free"), y=list(relation="free")),
   subset=flight=="pm"
)
```

It is quite difficult to understand how things vary between panels in this plot.

#### Sliced axes

Here is the plot with both axes "sliced":

```{r tracks_sliced, fig.height=4}
# example of both x and y axes "sliced"
xyplot(latitude ~ longitude | datCut,
   data=airplane,
   panel=arrowPanel,
   as.table=TRUE,
   between=list(x=0.25, y=0.25),
   layout=c(5, 2),
   scales=list(x=list(relation="sliced"), y=list(relation="sliced")),
   subset=flight=="pm"
)
```

Now we can make relative judgements between panels, but it is difficult to judge the magnitude of shifts in location from one panel to the other.

#### The prepanel function

One more notion to introduce in Trellis Display that will translate over to Trelliscope is that of a *prepanel function*.  A prepanel function can be used to determine the individual panel x and y axis data ranges from which the "same", "free", or "sliced" axis computations will be based.  

For example, suppose you are introducing other visual artifact to your panels other than the original data being plotted, and you would like to make sure that the axis limits account for the possibility of these extending beyond the range of the data being plotted.

Here is an example of using a prepanel function to specify that the axis limits should extend beyond the range of both the x and y-axis variables by 1 unit in each direction.  The prepanel function, like the panel function, takes the current x and y variables and must return a list that includes `xlim` and `ylim` which specify the axis limit range for each panel.

```{r tracks_prepanel, fig.height=4}
# prepanel example
xyplot(latitude ~ longitude | datCut,
   data=airplane,
   panel=arrowPanel,
   prepanel=function(x, y) {
      list(xlim=range(x) + c(-1, 1), ylim=range(y) + c(-1, 1))
   },
   as.table=TRUE,
   between=list(x=0.25, y=0.25),
   layout=c(5, 2),
   scales=list(x=list(relation="free"), y=list(relation="free")),
   subset=flight=="pm"
)
```


<!-- latCuts <- seq(38.2, 39.4, by=0.1)
lonCuts <- seq(-121.8, -120.8, by=0.1)

xyplot(latitude ~ longitude, data=airplane,
   groups=airplane$dat_ams < as.POSIXct("2010-06-28 21:00:00 UTC"),
   panel=function(x, y, ...) {
      panel.abline(v=lonCuts, col="gray")
      panel.abline(h=latCuts, col="gray")
      panel.xyplot(x, y, ...)
   },
   aspect="iso"
) -->

### Visualization Databases ###

<!-- Now that we have looked a little at the data and covered some of the principles of Trellis Display, before moving on to Trelliscope Displays, let's first discuss how we can populate a visualization database with displays. -->

Throughout the course of an analysis, we create several visual displays, such as those seen so far.  To help both keep track of what has been done and communicate our work to others, we can organize our displays in a *visualization database* (VDB).  

In Trelliscope, a VDB is a collection of display objects that can either be simple plots created from various R plotting packages, like the ones we have seen so far, or Trelliscope displays, which are displays created for a divided dataset with a potentially very large number of subsets.  This type of display is discussed in detail in the [Trelliscope Displays](#division-with-datadr) section.  Trelliscope provides a way to view and interact with these displays, as well as easily embed them in a web notebook, which we discuss in the [Viewing Displays](#viewing-displays) and [Lab Notebooks](#lab-notebooks) sections.

Here, we will get introduced to a few of the commands for interacting with a VDB using Trelliscope. 

#### Connecting to a VDB

We have already initialized a VDB.  If we are in a new R session, we can re-connect to the VDB with the following:

```{r vdb_reinit}
# re-connect to our VDB
conn <- vdbConn("/private/tmp/vdbtest")
```

The other information about the VDB connection (such as its name) have been stored and are read in.  If you would like to reset a VDB connection's settings (such as for changing the VDB name), you can add `reset=TRUE` to the call.

Recall that `vdbConn()` sets a global option with the connection information such that all methods have access to this information without explicitly supplying the connection object all the time.

#### Adding a display to a VDB

Plots created with R packages `lattice` or `ggplot2`, as well as with any R expression that plots to a graphics device, can be added to a VDB with the function `addDisplay()`.  We will cover that here, and in the next section we will see how to create and add Trelliscope displays to a VDB.

Say that we would like to add one of our plots we have created so far to our VDB:

```{r add_display}
# add a lattice plot to our VDB
p <- xyplot(latitude ~ longitude | flight, 
   data=airplane,
   panel=function(x, y, ...) {
      panel.fill("#E0E0E0")
      panel.grid(h=-1, v=-1, col="lightgray")
      panel.xyplot(x, y, ...)
   },
   groups=altCut,
   between=list(x=0.5),
   aspect="iso",
   par.settings=list(superpose.symbol=list(col=brewer.pal(6, "Accent"))),
   auto.key=list(space="right"))

addDisplay(p, 
   name  = "tracks_byflight", 
   group = "exploratory",
   desc  = "The tracks of the airplane with a panel for each of the morning and evening flights.  Color by altitude of plane.",
   dim   = list(width=800, height=450, res=150))
```

There are three attributes we can specify to describe a display record being added to the VDB:

- `name`: the name of the display
- `group`: the group the display belongs to (default is `"common"`)
- `desc`: a description of the display

It is sufficient to just specify `name`, but specifying `group` is also recommended and is used to help organize plots by different aspects of the analysis.  It is also a good practice to provide a detailed description of the plot.

The `dim` argument is a list specifying the width and height of the resulting plot (in pixels), and the resolution of the raster image that will be created.

Adding displays to our VDB helps us document our displays in line with our analyses.  This makes the process of dissemination much easier, as we will see.  In the course of analysis, we can create many ineffective displays in our quest to understand the data.  But the displays that are insightful deserve the extra care of being documented and added to the VDB.

#### What a display looks like in the VDB

So what is actually happening when we create a display?  Trelliscope creates a directory for the display in the VDB directory and fills it with various pieces of metadata.  It also can hold the actual rendered panels, as is the case here.

Let's see what got created for this display:

```{r list_displays}
# list the files in the "displays" directory of the VDB
list.files(file.path(vdbDir, "displays"))
```

We see a file `_displayList.Rdata`, which is an object containing the grand list of all displays, as well as various pieces of metadata about the displays.  The other file, `"exploratory"` is a directory that corresponds to the group that our newly created display belongs to.  Any display with group `"exploratory"` will be put here.

```{r list_displays_co}
# list the files in the "exploratory" group
list.files(file.path(vdbDir, "displays", "exploratory"))
```

We see a directory for our display, `tracks_byflight` in here.  Let's see what is in this directory:

```{r list_displays_display}
# look at files in the "tracks_byflight" directory
list.files(file.path(vdbDir, "displays", "exploratory", "tracks_byflight"))
```

There are two files:
   - `displayObj.Rdata` is an R data object with all of the parameters that went in to creating the display
   - `thumb.png` is the rendered display

For Trelliscope displays, `thumb.png` is the rendering of one subset of the data.  There will also be a subdirectory, `panels`, which is a directory either containing the data against which the display is applied, or a collection of rendered panels.

#### Listing all displays

To see what displays have been created in a VDB, we can do the following:

```{r list_vdb_displays}
# list all displays in the VDB
listDisplays()
```

This provides some simple information about each display in the VDB.  The column `n` is the number of panels in the display, and the column `dataClass` indicates the connection type of the data from which the display was created (used for Trelliscope displays).

<!-- For more specific information about a display -->

#### Viewing displays

We can view a display with the following:

```{r view_example}
# view the tracks_by_flight display
view("tracks_byflight")
```

There is a much more interesting viewer for Trelliscope displays.

#### Removing displays

It is possible to overwrite a display, in which case the directory of the display being replaced is renamed with a `"_bak"` appended to its name.  

However, we may want to completely remove a display from our VDB.  We can do this with:

```r
removeDisplay("tracks_byflight")
```

While a display is uniquely identified by its name and group, we can get away with just specifying a name if it is unique.

